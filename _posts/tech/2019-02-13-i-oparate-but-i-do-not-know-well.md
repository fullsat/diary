---
title:  "俺は雰囲気でPostgreSQLの運用をやっている"
date:   2019-02-13 21:00:00 +0900
category: tech
tags: postgresql
layout: post
---

「全然わからない、俺は雰囲気でPostgreSQLをやっている」

そう言いたくなるくらい、PostgreSQLのこと全然わかってないなと痛感しました。

# 何があったか

有名かはわかりませんが、下記のエラーが発生していました。

```
ERROR:  canceling statement due to conflict with recovery
```

レプリカの方でそこそこ時間のかかるSELECTを実行していると突然キャンセルされる現象です。

[こことか](https://soudai.hatenablog.com/entry/2017/12/25/104556)
[ここ](https://qiita.com/sawada_masahiko/items/16a30b2df52331c86483)
に書いてあるようなことです。

このエラーが発生する流れに関して勘違いをしていたということが判明して、
何をどう勘違いしたのかまとめておこうかと思います。

実はこれから書こうとしていることは裏を取っていないので、
調べる前に現状の認識をまとめておこうという意図で書こうとしています。

# 勘違いしていたこと

このエラーの発生する流れを勘違いしていました。
以下のとおりです。

* 2台以上で非同期レプリケーションのクラスタ構成を組んでいる
* 1台はマスターとして読み書きできる
* 残りのノードはレプリカとして読み込みしかできない

この構成に置いて

1. レプリカで負荷のかかるSELECTを実行する(以下ずっと実行されたままの状態であると仮定する)
2. SELECTのAccessShareLockが取得される
3. 負荷のかかるSELECT実行中にマスター側にUPDATEを実行する
4. レプリカにWALが送られる
5. WALをレプリカに反映しようとする
6. 反映しようとするがAccessShareLockがあるためコンフリクトする
7. コンフリクトしてからmax_standby_streaming_delay秒だけ待ってSELECTをキャンセルする

こう思っていました。

しかし、SELECTしか利用できないはずのレプリカに対しては、負荷のかかるクエリを実行したいはずです。

それなのに、上記の流れだと、UPDATEを実行するたびに、SELECTがキャンセルされかねません。

すべてのSELECTはmax_standby_streaming_delay秒以内に終わらせないといけないことになります。

何かがおかしいことにここでようやく気づきました。

# おそらく正しい認識

冒頭にも挙げた、[ここ](https://qiita.com/sawada_masahiko/items/16a30b2df52331c86483)
を読むと

>スレーブでの参照とスレーブが参照しているタプルを物理削除するWAL(VACUUM等で出力される)の適用がコンフリクトします。

とありました、これはつまり

1. レプリカで負荷のかかるSELECTを実行する(以下ずっと実行されたままの状態であると仮定する)
2. SELECTで参照している部分がマスター側で削除フラグが立てられてVACUUMにより物理削除したWALが作られる
3. レプリカにWALが送られる
4. WALをレプリカに反映しようとする
5. 反映するとすでに参照されていない領域にアクセスすることとなりコンフリクトする
6. コンフリクトしてからmax_standby_streaming_delay秒だけ待ってSELECTをキャンセルする

# まとめ

勘違いしていた！と書いてはいるものの裏を取っていないので、
ここに書いていたことすら勘違いということもあります。

クラスタを組んで実験します(明日)(時間があれば)

さあ、あと何回恥の上塗りをすれば気が済むのでしょうか？

言い訳をしておくと、マスター側のAccessExclusiveLockを含むWAL反映中のSELECTの状態と同じだと認識していました。

こちらの認識も正しいかどうか実験して調べてみます(明日)(時間があれば)

さて、実験もせずに書いていることからも、タイトル通り雰囲気でPostgreSQLをやっているとおわかりいただけたでしょうか？

明日から雰囲気じゃなくやっていくぞという、自戒をこめてこの文をしめます。以上

---
title:  "Lambda@Edgeはterraformで管理すべきではなかった"
date:   2019-02-05 22:50:00 +0900
category: tech
tags: aws lambda
layout: post
---

terraformで管理すべきものとそうでないものがあると思っています。

タイトルにあるとおりLamda@Edgeはterraform管理下に置くべきではなかったなと思いました。

## 何があったか

まずはじめにLambda@Edgeを使おうぜ！となりました。

Infrastructure as Codeを進めているので当然terraformで作成することになります。

terraformを書いていくうちに、CloudFrontのlambda_function_associationは、バージョン情報も含めたarnを指定しなければならないことに気づきました。

ここで運用のことを考えますが、lambda関数を更新するのは誰でしょうか？

私の場合は、関数を作った人(私ではない誰か)が更新することになっていました。

しかし初回のプロビジョニングのときはterraformでlambda関数の作成とデプロイをすることになります。

空でもいいので関数のコードがないといけないからです。

その後何が起こるかと言うと、terraform管理下に置いているはずのlambda関数に対して、別のプロセスで更新をかけると(マネジメントコンソールから直接コードを変更など)、再度terraform applyをした時に仮のコードへと戻ってしまいます。

さてどうしたかと言うと、cloudfrontのlambda関数との関連はignore_changesを利用してterraform管理下から外しました。

※default_behaviorにedgeが設定されているとcloudfront自体も管理対象外としなくてはなりませんでしたが、ordereded_behaviorのほうだったので助かりました。

## 何を管理するのかしないのか

私の経験上、こういうことは以前にもありました。

ECSのタスク定義です。

CodePipelineで更新していくとterraformの管理下のものとは別のバージョンが指定されることになります。

CodePipelineでタスク定義のバージョンが更新された状態で、再度terraform applyするとバージョンがもとに戻ろうとする動きになります。

別の経験もあります。

ALBのターゲットグループにぶら下げるインスタンスです。

運用上柔軟に変更したいはずで、調子が悪いからと外した状態でterraform applyするとこのインスタンス接続されてない！と怒られます。

なのでALBのターゲットグループの関連もterraform管理下からは除外しています。

ここれらの経験を一言でまとめると

* terraform以外から変更を加える運用があるならそれはterraformで管理すべきじゃない

ということになります。

アプリケーションのバージョンは自分が管理するterraform以外から更新がかかります。

ALBのターゲットグループはメトリクスに応じてAPIから更新がかかります。

terraformはあくまでも静的なプロビジョニングのツールなので、動的な変更は苦手な分野です。

関連の更新とアプリケーションの更新、このあたりは十分に運用を吟味する必要があるかと思います。

## 最後に

もちろん私のユースケースでは管理すべきではないという話で、コードの中身もすべてterraformで管理するなら管理下におけば良いんじゃないかと思います
